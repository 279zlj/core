//
// Файл    : ps_hls.txt
//

//
// глобальные константы
//

sampler BaseTex; // текстура

float dhue = 0;
float dsat = 0;

//
// стуктуры
//

struct PS_INPUT
{
     float2 base : TEXCOORD0;
};

struct PS_OUTPUT
{
     vector diffuse : COLOR0;
};

//
// главная функция
//

PS_OUTPUT Main(PS_INPUT input)
{
	// Обнуляем члены выходной структуры
	PS_OUTPUT output = (PS_OUTPUT)0;

	vector clr = tex2D(BaseTex, input.base);
	vector hls = clr;
	
	//
	// прямое преобразование

	float MAX = max( max(clr.r, clr.g), clr.b );
	float MIN = min( min(clr.r, clr.g), clr.b );
	float SUB = MAX - MIN;
	float ADD = MAX + MIN;

	//
	// hue
	
	float3 tmp;
	tmp.r = clr.g - clr.b;
	tmp.g = clr.b - clr.r;
	tmp.b = clr.r - clr.g;

	float factor = 60 / SUB;
	const float3 c_disp = {0, 120, 240};

	tmp = tmp * factor + c_disp;
	
	clr -= MAX;
	hls.r = (clr.b >= 0) ? tmp.b : hls.r;
	hls.r = (clr.g >= 0) ? tmp.g : hls.r;
	hls.r = (clr.r >= 0) ? tmp.r : hls.r;

	if( hls.r < 0 ) hls.r += 360;

	//
	// lightness
	
	hls.g = ADD / 2;
	
	//
	// saturation
	
	hls.b = SUB / (1 - abs(ADD - 1));
	hls.b = (hls.b <= 0) ? 0 : hls.b;
	hls.b = (hls.b >= 1) ? 1 : hls.b;
	
	//
	// shift hue
	
	hls.r += dhue;
	if( hls.r < 0 )
		hls.r += 360;

	if( hls.r >= 360 )
		hls.r -= 360;
		
	//
	// shift saturation
	hls.b = saturate(hls.b * dsat);
	
	//
	// обратное преобразование
	
	clr.a = hls.a;
	
	hls.b *= 0.5 - abs(hls.g - 0.5);
	
	vector buf = {-2, -6, -8, 0};
	buf += hls.r / 30;

	tmp.x = hls.g - hls.b;
	tmp.y = hls.g + hls.b;
	tmp.z = hls.g + hls.b * 7;
	
	//
	// green
	
	float case1 = (tmp.x + hls.b * buf.w);
	float case2 = (tmp.z - hls.b * buf.w);
	
	clr.g = (buf.x < 0) ? case1 : tmp.y;
	clr.g = (buf.y < 0) ? clr.g : case2;
	clr.g = (buf.z < 0) ? clr.g : tmp.x;
	
	// 
	// red
	
	buf += (buf.w >= 8) ? -8 : 4;
	
	case1 = (tmp.x + hls.b * buf.w);
	case2 = (tmp.z - hls.b * buf.w);
	
	clr.r = (buf.x < 0) ? case1 : tmp.y;
	clr.r = (buf.y < 0) ? clr.r : case2;
	clr.r = (buf.z < 0) ? clr.r : tmp.x;
	
	//	
	// blue
	
	buf += (buf.w >= 8) ? -8 : 4;
	
	case1 = (tmp.x + hls.b * buf.w);
	case2 = (tmp.z - hls.b * buf.w);

	clr.b = (buf.x < 0) ? case1 : tmp.y;
	clr.b = (buf.y < 0) ? clr.b : case2;
	clr.b = (buf.z < 0) ? clr.b : tmp.x;

	output.diffuse = clr;
	
	return output;
}